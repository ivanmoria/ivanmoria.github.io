import os
import sys
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import subprocess
import seaborn as sns

from matplotlib.patches import Rectangle
import colorsys
from collections import defaultdict
from scipy.stats import linregress
from PyQt5.QtWidgets import (QApplication, QMainWindow, QLabel, QPushButton, QColorDialog, QSpacerItem, 
                             QMessageBox, QVBoxLayout, QHBoxLayout, QWidget, QCheckBox, QSizePolicy, 
                             QLineEdit, QComboBox, QFileDialog, QScrollArea, QTabWidget,QLayout, QGridLayout, QInputDialog, QGroupBox)
from PyQt5.QtCore import Qt

from PyQt5.QtGui import QColor, QFont, QPalette

class PlotarGrafico(QMainWindow):
    
    def abrir_pasta(self, event):
        diretorio = self.lineedit_dir.text()
        if sys.platform == "win32":
            os.startfile(diretorio)
        elif sys.platform == "darwin":
            subprocess.call(["open", diretorio])
        else:
            subprocess.call(["xdg-open", diretorio])
   
    def __init__(self):
        super().__init__()
        
        self.setWindowTitle("Extração e Processamento de Informações Musicais em Musicoterapia")
        self.setGeometry(200, 100, 500, 700)
        self.default_directory = "/Users/imac/Documents/takes_vestigios/files/"
        self.main_layout = QVBoxLayout()
        self.checkboxes_arquivos = {}  
        self.takes_checkboxes = {}
        self.figsize_options = {  
        "Tamanho Único de Coluna (80 mm)": (3.15, 2.36),
        "Tamanho Duplo de Coluna (170 mm)": (6.69, 5.51),
        "Tamanho de Página Inteira (210 mm)": (8.27, 5.83),
        "Customizado (254mm)": (10, 8)   }
        self.main_layout.setContentsMargins(5, 5, 5, 5)  # Remove margins around the main layout
        dir_layout = QHBoxLayout()
        group_box = QGroupBox("Selecionar Diretório")
        group_layout = QHBoxLayout()
        group_box.setLayout(group_layout)
        dir_layout.addWidget(group_box)
        self.lineedit_dir = QLineEdit(self.default_directory)
        self.lineedit_dir.setReadOnly(True)
        self.lineedit_dir.setFrame(False)
        self.lineedit_dir.setCursor(Qt.DragLinkCursor)
        self.lineedit_dir.mousePressEvent = self.abrir_pasta  
        self.btn_select_dir = QPushButton("Abrir")
        self.btn_select_dir.setStyleSheet("""
            QPushButton {
                border: 2px solid #8f8f91;
                border-radius: 10px;
                background-color: transparent;
                color: black;
                padding: 1px;
            }
            QPushButton:hover {
                background-color: #2E8B57;
            }
            QPushButton:pressed {
                background-color: #32CD32; 
            }
        """)
        self.btn_select_dir.setFixedWidth(100)
        self.btn_select_dir.clicked.connect(self.selecionar_pasta)
        self.btn_select_dir.setCursor(Qt.WhatsThisCursor)
        group_layout.addWidget(self.btn_select_dir)
        group_layout.addWidget(self.lineedit_dir)
        group_box.setMinimumWidth(450)  
        btn_box = QGroupBox("Configurações de Paleta")
        btn_layout = QVBoxLayout()
        btn_box.setMinimumWidth(150)  
        self.btn_change_palette = QPushButton("Paleta: pastel")
        self.btn_change_palette.clicked.connect(self.change_palette)
        self.btn_reset_colors = QPushButton("Restaurar")
        self.btn_reset_colors.clicked.connect(self.reset_colors)
        self.btn_change_palette.setCursor(Qt.OpenHandCursor)
        self.btn_reset_colors.setCursor(Qt.ClosedHandCursor)
        btn_layout.addWidget(self.btn_change_palette)
        btn_layout.addWidget(self.btn_reset_colors)
        btn_box.setLayout(btn_layout)
        btn_layout.setSpacing(2) 
        btn_layout.setContentsMargins(0, 0, 0, 0)  
        self.btn_change_palette.setStyleSheet("""
    QPushButton {
        border: 2px solid #8f8f91;
        border-radius: 10px;
        background-color: transparent;
        color: black;
        padding: 5px;
    }
    QPushButton:hover {
        background-color: #3c8dbc;
    }
    QPushButton:pressed {
        background-color: #1c5c9c;
    }
""")
        self.btn_reset_colors.setStyleSheet("""
            QPushButton {
                border: 2px solid #8f8f91;
                border-radius: 10px;
                background-color: transparent;
                color: black;
                padding: 1px;
            }
            QPushButton:hover {
                background-color: #2E8B57;
            }
            QPushButton:pressed {
                background-color: #32CD32; 
            }
        """)
        save_box = QGroupBox("Salvar arquivos plotados")
        save_layout = QHBoxLayout()
        save_box.setLayout(save_layout)
        dir_layout.addWidget(save_box)
        self.save_checkbox = QCheckBox("Salvar figura")
        self.save_checkbox.setChecked(False)
        self.save_name_input = QLineEdit()
        self.save_name_input.setMaximumWidth(200) 
        self.save_name_input.setPlaceholderText("nome padrão")
        self.save_name_input.setCursor(Qt.IBeamCursor)
        self.save_checkbox.setCursor(Qt.WhatsThisCursor)
        save_layout.addWidget(self.save_checkbox)
        save_layout.addWidget(self.save_name_input)
        file_layout = QVBoxLayout()
        file_layout.setSizeConstraint(QLayout.SetFixedSize) 
        scroll_widget_file = QWidget()
        scroll_layout_file = QVBoxLayout(scroll_widget_file)
        scroll_area_file = QScrollArea()
        self.grid_layout = QGridLayout()
        scroll_layout_file.addLayout(self.grid_layout)
        scroll_widget_file.setLayout(scroll_layout_file)
        scroll_area_file.setWidget(scroll_widget_file)
        scroll_area_file.setWidget(scroll_widget_file)
        scroll_area_file.setWidgetResizable(True)
        scroll_area_file.setMaximumSize(1500, 1300)
        file_layout.addWidget(scroll_area_file)
        take_layout = QHBoxLayout()
        take_layout.setSizeConstraint(QLayout.SetFixedSize) 
        scroll_widget_take = QWidget()
        scroll_layout_take = QHBoxLayout(scroll_widget_take)
        self.take_layout = QHBoxLayout()
        scroll_layout_take.addLayout(self.take_layout)
        scroll_widget_take.setLayout( scroll_layout_take)
        take_layout.addWidget(scroll_widget_take)
        scroll_widget_take.setMaximumSize(1500, 100)

     
     
        plt_layout = QHBoxLayout()
        plot_box = QGroupBox("Opções de Plotagem")
        plot_layout = QVBoxLayout()
        plot2_layout = QVBoxLayout()
        plot3_layout = QHBoxLayout()
        plot4_layout = QHBoxLayout()
        plot_box.setLayout(plot3_layout)
        
        plt_layout.addWidget(btn_box)
        plt_layout.addWidget(plot_box)
        plot_box.setCursor(Qt.WhatsThisCursor)
        self.regression_checkbox = QCheckBox("Plotar regressão linear")
        self.regression_checkbox.setChecked(False)
        self.scatter_checkbox = QCheckBox("Plotar bolinhas")
        self.scatter_checkbox.setChecked(True)
        self.scatter_percentage_combobox = QComboBox()
        self.plotar_press_dur= QCheckBox("Plotar Press_dur")
        self.plotar_press_dur.setChecked(True)
        self.scatter_percentage_combobox.addItems(["0", "25", "50", "75", "100"])
        self.scatter_percentage_combobox.setCurrentText("100")
        self.connect_dots_checkbox = QCheckBox("Ligar as bolinhas")
        self.time_between_press_checkbox = QCheckBox("Plotar tempo entre pressionadas")
        self.time_between_press_checkbox.setChecked(True)
        self.connect_dots_checkbox.setChecked(True)
        self.legend_checkbox = QCheckBox("Plotar legendas")
        self.legend_checkbox.setChecked(True)
        
        
        self.mean_velocity_checkbox = QCheckBox("Plotar média da velocidade")
        self.mean_velocity_checkbox.setChecked(False)
        plot4_layout.addWidget(self.connect_dots_checkbox)
        plot4_layout.addWidget(self.scatter_checkbox)
        plot2_layout.addWidget(self.plotar_press_dur)
        plot_layout.addWidget(self.regression_checkbox)
        plot4_layout.addWidget(self.scatter_percentage_combobox)
        plot2_layout.addWidget(self.time_between_press_checkbox)
        plot2_layout.addWidget(self.mean_velocity_checkbox)
        plot2_layout.addWidget(self.legend_checkbox)
        plot3_layout.addLayout(plot_layout)
        plot3_layout.addLayout(plot2_layout)
        plot_layout.addLayout(plot4_layout)
        self.single_figure_checkbox = QCheckBox("Plotar junto")
        self.single_figure_checkbox.setChecked(True)

        plot_layout.addWidget(self.single_figure_checkbox)

        fig_box = QGroupBox("Opções da Figura")
        img_layout = QVBoxLayout()
        fig_layout = QHBoxLayout()
        fig_box.setLayout(img_layout)
        fig_box.setCursor(Qt.WhatsThisCursor)
        size_dpi_layout = QHBoxLayout()
        size_label = QLabel("Dimensão:")
        self.figsize_combobox = QComboBox()
        self.figsize_combobox.addItems(["Tamanho Único de Coluna (80 mm)","Tamanho Duplo de Coluna (170 mm)","Tamanho de Página Inteira (210 mm)","Customizado (254mm)"])
        self.figsize_combobox.setCurrentText("Customizado (254mm)")
        self.figsize_combobox.setMaximumWidth(200) 
        self.figsize_combobox.currentIndexChanged.connect(self.handle_combobox_change)
        dpi_label = QLabel("DPI:")
        self.dpi_combobox = QComboBox()
        self.dpi_combobox.addItems(["100", "150", "200", "300", "600"])
        resolution_label = QLabel("Resolução:")
        self.resolution_combobox = QComboBox()
        self.resolution_combobox.addItems(["480p", "720p", "1080p", "4K"])
        self.resolution_combobox.setCurrentText("1080p")
        size_dpi_layout.addWidget(size_label)
        size_dpi_layout.addWidget(self.figsize_combobox)
        size_dpi_layout.addWidget(QLabel(" "))  
        fig_layout.addWidget(dpi_label)
        fig_layout.addWidget(self.dpi_combobox)
        fig_layout.addWidget(resolution_label)
        fig_layout.addWidget(self.resolution_combobox)
        img_layout.addLayout(size_dpi_layout)
        img_layout.addLayout(fig_layout)
        plt_layout.addWidget(fig_box)
        button_layout = QHBoxLayout()
        self.btn_plotar = QPushButton("Plotar Gráfico")
        button_layout.addWidget(self.btn_plotar)
        font = self.btn_plotar.font()
        font.setPointSize(16)
        font.setFamily("Quicksand")
        font.setBold(True)
        self.btn_plotar.setFont(font)
        self.btn_plotar.setStyleSheet("""
            QPushButton {
                border: 2px solid #8f8f91;
                border-radius: 10px;
                background-color: transparent;
                color: black;
                padding: 5px;
            }
            QPushButton:hover {
                background-color: #3c8dbc;
            }
            QPushButton:pressed {
                background-color: #1c5c9c;
            }
        """)
        largura = 450
        altura = 50
        self.btn_plotar.setFixedSize(largura, altura)
        self.main_layout.addLayout(dir_layout)
        self.main_layout.addLayout(plt_layout)
        self.main_layout.addLayout(take_layout)
        self.main_layout.addLayout(file_layout)
        self.main_layout.addLayout(button_layout)
        central_widget = QWidget()
        central_widget.setLayout(self.main_layout)
        self.setCentralWidget(central_widget)
        self.default_colors = sns.color_palette("pastel", 12).as_hex()
        self.carregar_nomes_arquivos()
        self.btn_plotar.clicked.connect(self.plotar_grafico)
        self.ajustar_geometria_janela()
        self.cores_selecionadas = {} 
        self.reset_colors()
    def handle_combobox_change(self, index):
        MM_TO_INCHES = 0.0393701  # Fator de conversão de milímetros para polegadas
        MAX_SIZE_MM = 65536 * 0.0393701  # Convertendo o limite máximo de pixels para milímetros (cerca de 2499.78 mm)
        INITIAL_SIZE_MM = 254
        if self.figsize_combobox.itemText(index).startswith("Customizado"):
            while True:
                text, ok = QInputDialog.getText(self, 'Tamanho Personalizado', '<center>Digite o tamanho da figura em mm</center>''<i>Fator de conversão de milímetros para polegadas: </i><font color="red">0.0393701</font>')
                if ok:
                    try:
                        if text.strip():  # Se o campo de texto não estiver vazio
                            size_mm = int(text)
                            if size_mm <= 0:
                                raise ValueError("O valor deve ser maior que zero.")
                            if size_mm > MAX_SIZE_MM:
                                raise ValueError(f"O valor não pode exceder {int(MAX_SIZE_MM)} mm.")
                            size_inches = size_mm * MM_TO_INCHES
                            self.figsize_options["Customizado"] = (size_inches, size_inches)
                            custom_size_text = f"Customizado ({size_mm} mm)"
                            self.figsize_combobox.setItemText(index, custom_size_text)
                        else:
                            # Se o campo de texto estiver vazio, restaura para o valor inicial
                            size_inches = INITIAL_SIZE_MM * MM_TO_INCHES
                            self.figsize_options["Customizado"] = (size_inches, size_inches)
                            custom_size_text = f"Customizado ({INITIAL_SIZE_MM} mm)"
                            self.figsize_combobox.setItemText(index, custom_size_text)
                        break  # Sai do loop se um valor válido for inserido
                    except ValueError as e:
                        message_box = QMessageBox()
                        message_box.setWindowTitle("Erro")
                        message_box.setText(f"'{text}' não é um número.")
                        message_box.setInformativeText("Tente outra vez!")
                        message_box.setIcon(QMessageBox.Question)
                        message_box.exec_()
                else:
                    # Se o usuário clicar em Cancelar, sai do loop sem fazer alterações
                    break
    def ajustar_geometria_janela(self):
        desktop = QApplication.desktop()
        screen_rect = desktop.screenGeometry()
        min_height = screen_rect.height() * 0.8  # Definindo a altura máxima como 80% da altura do monitor
        if self.height() > min_height:
            self.setFixedHeight(min_height)
    def selecionar_pasta(self):
        pasta = QFileDialog.getExistingDirectory(self, "Selecione o Diretório", self.lineedit_dir.text())
        if pasta:
                self.lineedit_dir.setText(pasta)
                self.carregar_nomes_arquivos()
                self.atualizar_interface()
    def selecionar_cor(self, checkbox):
            cor_inicial = QColorDialog.getColor()
            if cor_inicial.isValid():
                for nome_arquivo, checkbox_arquivo in self.checkboxes_arquivos.items():
                    if checkbox_arquivo == checkbox:
                        checkbox_style = f"""QCheckBox::indicator {{ width: 20px; height: 20px; border-radius: 10px; border: 2px solid #2d2d2d; background-color: {cor_inicial.name()}; }} QCheckBox::indicator:checked {{ background-color: {cor_inicial.name()}; }} QCheckBox::indicator:unchecked {{ background-color: transparent; }}"""
                        checkbox_arquivo.setStyleSheet(checkbox_style)
                        self.cores_selecionadas[nome_arquivo] = cor_inicial.name()
                        break
    def carregar_takes(self, nome_arquivo):
        diretorio = self.lineedit_dir.text()
        arquivos = os.listdir(diretorio)
        takes = sorted(set([int(arquivo.split("_")[-1].split(".")[0]) for arquivo in arquivos if arquivo.startswith(nome_arquivo + "_take_") and arquivo.endswith(".csv")]))
        return takes
    def carregar_nomes_arquivos(self):
        diretorio = self.lineedit_dir.text()
        arquivos = os.listdir(diretorio)
        nomes_arquivos = sorted(list(set([arquivo.split("_")[0] for arquivo in arquivos if arquivo.endswith(".csv")])))

        self.list_cor_arquivo = {}
        self.checkboxes_arquivos = {}
        self.takes_checkboxes = {}
        self.take_group_checkboxes = []
        # Preenche o dicionário de takes_por_arquivo e calcula o número máximo de takes por arquivo
        takes_por_arquivo = {}
        max_takes_por_arquivo = {}

        for nome_arquivo in nomes_arquivos:
            takes_por_arquivo[nome_arquivo] = self.carregar_takes(nome_arquivo)
            max_takes_por_arquivo[nome_arquivo] = max(takes_por_arquivo[nome_arquivo], default=0)

        # Calcula o máximo número de takes entre todos os arquivos
        max_takes = max(max_takes_por_arquivo.values(), default=0)
    
        
        checkbox_style = """QCheckBox::indicator { width: 20px; height: 20px; border-radius: 10px; } QCheckBox::indicator:unchecked { background-color:; border: 2px solid #2d2d2d; } QCheckBox::indicator:checked { border: 2px solid #2d2d2d; }"""

        # Remove todos os widgets atuais do layout
        for i in reversed(range(self.grid_layout.count())): 
            widget_to_remove = self.grid_layout.itemAt(i).widget()
            self.grid_layout.removeWidget(widget_to_remove)
            widget_to_remove.setParent(None)

        for i in reversed(range(self.take_layout.count())): 
                widget_to_remove = self.take_layout.itemAt(i).widget()
                self.take_layout.removeWidget(widget_to_remove)
                widget_to_remove.setParent(None)

        nome_box = QGroupBox("Selecionar Arquivos")
        nomes_layout = QVBoxLayout()
        nome_box.setLayout(nomes_layout)
        self.label_nome_arquivo = QLabel("<i><font family='Arial' size='1'>nome_take_0</font></i>")
        self.label_nome_arquivo.setAlignment(Qt.AlignRight)
        self.checkbox_select_all = QCheckBox("Marcar todos")
        self.checkbox_select_all.stateChanged.connect(self.selecionar_todos_nomes)
        nomes_layout.addWidget(self.checkbox_select_all)
        nomes_layout.addWidget(self.label_nome_arquivo)
        self.checkbox_select_all.setCursor(Qt.WhatsThisCursor)
        nome_box.setFixedWidth(140)
        nomes_layout.setSpacing(2)
        nomes_layout.setContentsMargins(0, 6, 0, 0)
        nome_box.setFixedHeight(57)
        checkbox_box = QGroupBox()
        checkbox_layout = QHBoxLayout()
        checkbox_box.setLayout(checkbox_layout)
        checkbox_box.setFixedHeight(45)
        nome_box.setMinimumWidth(123)  # Defina a largura mínima desejada
        nome_box.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Preferred)  # Ajuste a política de tamanho
        nome_box.setAlignment(Qt.AlignCenter)  # Alinha o texto no centro

        for take in range(1, max_takes + 1):
            take_group_checkbox = QCheckBox(f" {take}")
            take_group_checkbox.clicked.connect(lambda state, t=take: self.selecionar_todos_takes_nomes(t, state))
            checkbox_layout.addWidget(take_group_checkbox)
            self.take_group_checkboxes.append(take_group_checkbox)

        checkbox_box.setCursor(Qt.DragMoveCursor)
        take_group_layout = QHBoxLayout()
        checkbox_layout.setSpacing(30)
        take_group_layout.addWidget(nome_box)
        take_group_layout.addWidget(checkbox_box)
        take_group_layout.setContentsMargins(0, 0, 0, 0)
        takess_scroll_widget = QWidget()
        takess_scroll_widget.setLayout(take_group_layout)
        takess_scroll_area = QScrollArea()
        takess_scroll_area.setWidgetResizable(True)
        takess_scroll_area.setWidget(takess_scroll_widget)
        takess_scroll_area.setMinimumSize(800, 64)
        takess_scroll_widget.setCursor(Qt.DragMoveCursor)
    
        self.take_layout.addWidget(nome_box, 0 )
        self.take_layout.addWidget(takess_scroll_area, 2)

        for idx, nome_arquivo in enumerate(nomes_arquivos):
            checkbox_arquivo = QCheckBox()
            nomes_label = QLabel(nome_arquivo)
            checkbox_arquivo.clicked.connect(lambda state, nome=nome_arquivo: self.selecionar_todos_takes(nome, state))

            cor_padrao = self.default_colors[idx % len(self.default_colors)]
            checkbox_arquivo.setStyleSheet(checkbox_style + f"QCheckBox::indicator:checked {{ background-color: {cor_padrao}; }}")

            checkbox_arquivo.setCursor(Qt.WhatsThisCursor)
            nomes_label.setCursor(Qt.ForbiddenCursor)
            nomes_label.setMinimumWidth(123)  
            nomes_label.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Preferred)  
            nomes_label.setAlignment(Qt.AlignCenter)  
            
            self.checkboxes_arquivos[nome_arquivo] = checkbox_arquivo
            nomes_label.mousePressEvent = lambda event, cb=checkbox_arquivo: self.selecionar_cor(cb)

            takes_layout = QHBoxLayout()
            takes_layout.setContentsMargins(0, 0, 0, 0)
            takes_layout.setSpacing(10)
            takes_scroll_widget = QWidget()
            takes_scroll_widget.setLayout(takes_layout)
            takes_scroll_area = QScrollArea()
            takes_scroll_area.setWidgetResizable(True)
            takes_scroll_area.setMinimumWidth(123)
            takes_scroll_area.setWidget(takes_scroll_widget)
            takes_scroll_area.setMinimumSize(800, 50)
            takes_scroll_widget.setCursor(Qt.DragMoveCursor)

            self.grid_layout.addWidget(nomes_label, idx, 1, 1, 1)  # (widget, row, column, rowSpan, columnSpan)
            self.grid_layout.addWidget(checkbox_arquivo,idx, 0 )
            self.grid_layout.addWidget(takes_scroll_area,  idx, 2)

            for take in range(1, max_takes + 1):
                take_checkbox = QCheckBox(f"Take {take}")
                if take in takes_por_arquivo[nome_arquivo]:
                    take_checkbox.setChecked(False)
                else:
                    take_checkbox.setChecked(False)
                    take_checkbox.setEnabled(False)
                takes_layout.addWidget(take_checkbox)
                self.takes_checkboxes[(nome_arquivo, take)] = take_checkbox

        for (nome_arquivo, take), checkbox in self.takes_checkboxes.items():
            checkbox.clicked.connect(lambda state, nome=nome_arquivo: self.selecionar_nome_arquivo(nome, state))
            
    def selecionar_nome_arquivo(self, nome_arquivo, state):
        if state:
            self.checkboxes_arquivos[nome_arquivo].setChecked(True)
        at_least_one_take_checked = any(checkbox.isChecked() for (n, t), checkbox in self.takes_checkboxes.items() if n == nome_arquivo)
        self.checkboxes_arquivos[nome_arquivo].setChecked(at_least_one_take_checked)
   
    def selecionar_todos_takes(self,  nome_arquivo, state):
        for (nome, t), checkbox in self.takes_checkboxes.items():
            if nome == nome_arquivo and checkbox.isEnabled():  # Verifica se o checkbox está ativado
                checkbox.setChecked(state)
                    
    def selecionar_todos_takes_nomes(self, take, state):
        for (nome_arquivo, t), checkbox in self.takes_checkboxes.items():
            if t == take and checkbox.isEnabled():
                checkbox.setChecked(state)
                
        # Verificar se pelo menos um "take" está marcado para cada arquivo e atualizar o checkbox do arquivo
        for nome_arquivo in self.checkboxes_arquivos:
            at_least_one_take_checked = any(checkbox.isChecked() for (n, t), checkbox in self.takes_checkboxes.items() if n == nome_arquivo)
            self.checkboxes_arquivos[nome_arquivo].setChecked(at_least_one_take_checked)

    # Marca/desmarca todos os checkboxes de arquivos

    def selecionar_todos_nomes(self, state):
        # Marca todos os checkboxes de arquivos
        for checkbox_arquivo in self.checkboxes_arquivos.values():
            checkbox_arquivo.setChecked(state == Qt.Checked)

        # Marca todos os checkboxes de "takes" fora do grupo
        for (n, t), take_checkbox in self.takes_checkboxes.items(): 
            if take_checkbox.isEnabled():
                take_checkbox.setChecked(state == Qt.Checked)

        # Marca todos os checkboxes dentro do grupo take_group_layout
        for take_group_checkbox in self.take_group_checkboxes:
            take_group_checkbox.setChecked(state == Qt.Checked)
  
    def reset_colors(self):
        for nome_arquivo, btn_cor in self.list_cor_arquivo.items():
            cor_padrao = self.default_colors[list(self.list_cor_arquivo.keys()).index(nome_arquivo) % len(self.default_colors)]
            btn_cor.setStyleSheet(f"background-color: {cor_padrao}; border-radius: 10px")
            
        for nome_arquivo, checkbox_arquivo in self.checkboxes_arquivos.items():
            cor_padrao = self.default_colors[list(self.checkboxes_arquivos.keys()).index(nome_arquivo) % len(self.default_colors)]
                      
            checkbox_style = """QCheckBox::indicator { width: 20px; height: 20px; border-radius: 10px; } QCheckBox::indicator:unchecked { background-color:; border: 2px solid #2d2d2d; } QCheckBox::indicator:checked { border: 2px solid #2d2d2d; }"""
            checkbox_arquivo.setStyleSheet(checkbox_style + f"QCheckBox::indicator:checked {{ background-color: {cor_padrao}; }}")
            self.cores_selecionadas[nome_arquivo] = cor_padrao
        
        self.btn_change_palette.setText("Paleta: pastel")     # Atualizar o texto do botão de alterar paleta para refletir a paleta padrão
        self.btn_change_palette.setStyleSheet(f"""QPushButton {{border: 2px solid #8f8f91;border-radius: 10px;background-color: transparent;color: black;padding: 5px;}}QPushButton:hover {{background-color: {self.default_colors[1]};}}QPushButton:pressed {{background-color: {self.default_colors[2]};}}""")
        self.btn_reset_colors.setStyleSheet(f"""QPushButton {{border: 2px solid #8f8f91;border-radius: 10px;background-color: transparent;color: black;padding: 5px;}}QPushButton:hover {{background-color: {self.default_colors[3]};}}QPushButton:pressed {{background-color: {self.default_colors[4]};}}""")
        
        
        self.btn_plotar.setStyleSheet(f"""QPushButton {{border: 2px solid #8f8f91;border-radius: 10px;background-color: transparent;color: black;padding: 5px;}}QPushButton:hover {{background-color: {self.default_colors[5]};}}QPushButton:pressed {{background-color: {self.default_colors[8]};}}""")
        self.btn_select_dir.setStyleSheet(f"""QPushButton {{border: 2px solid #8f8f91;border-radius: 10px;background-color: transparent;color: black;padding: 5px;}}QPushButton:hover {{background-color: {self.default_colors[10]};}}QPushButton:pressed {{background-color: {self.default_colors[9]};}}""")

    def change_palette(self):
        # Abrir um diálogo de seleção de paleta
        paleta, aceito = QInputDialog.getItem(self, "Selecionar Paleta", "Escolha a paleta:", 
["deep", "muted", "bright", "pastel", "dark", "colorblind", "viridis", "plasma", "inferno", "magma", "cividis", "RdYlBu", "PiYG", "PRGn", "RdYlGn", "BrBG", "RdGy", "PuOr", "Set2", "Set3", "tab10", "tab20", "tab20b", "tab20c"], 0, False)
        if aceito: 
            cores_palette = sns.color_palette(paleta, 12).as_hex()             # Definir a paleta selecionada

            # Atualizar as cores dos botões na interface
            for nome_arquivo, btn_cor in self.list_cor_arquivo.items():
                cor_palette = cores_palette[list(self.list_cor_arquivo.keys()).index(nome_arquivo) % len(cores_palette)]
                btn_cor.setStyleSheet(f"background-color: {cor_palette}; border-radius: 10px")
              # Atualizar as cores das caixas de seleção na interface
            
            for nome_arquivo, checkbox_arquivo in self.checkboxes_arquivos.items():
                cor_palette = cores_palette[list(self.checkboxes_arquivos.keys()).index(nome_arquivo) % len(cores_palette)]
                
                checkbox_style = """QCheckBox::indicator { width: 20px; height: 20px; border-radius: 10px; } QCheckBox::indicator:unchecked { background-color:; border: 2px solid #2d2d2d; } QCheckBox::indicator:checked { border: 2px solid #2d2d2d; }"""
                checkbox_arquivo.setStyleSheet(checkbox_style + f"QCheckBox::indicator:checked {{ background-color: {cor_palette}; }}")
                self.cores_selecionadas[nome_arquivo] = cor_palette
            # Atualizar o texto do botão para refletir a paleta selecionada
            self.btn_change_palette.setText(f"Paleta: {paleta}")
            self.btn_change_palette.setStyleSheet(f"""QPushButton {{border: 2px solid #8f8f91;border-radius: 10px;background-color: transparent;color: black;padding: 5px;}}QPushButton:hover {{background-color: {cores_palette[1]};}}QPushButton:pressed {{background-color: {cores_palette[2]};}}""")

            self.btn_reset_colors.setStyleSheet(f""" QPushButton {{border: 2px solid #8f8f91;border-radius: 10px; background-color: transparent;color: black;padding: 5px; }}QPushButton:hover {{ background-color: {cores_palette[3]};}}QPushButton:pressed {{background-color: {cores_palette[4]};}}""")

            self.btn_plotar.setStyleSheet(f""" QPushButton {{ border: 2px solid #8f8f91; border-radius: 10px; background-color: transparent; color: black; padding: 5px; }} QPushButton:hover {{ background-color: {cores_palette[5]}; }} QPushButton:pressed {{ background-color: {cores_palette[8]};}}""")

            self.btn_select_dir.setStyleSheet(f""" QPushButton {{ border: 2px solid #8f8f91; border-radius: 10px; background-color: transparent; color: black; padding: 5px; }} QPushButton:hover {{background-color: {self.default_colors[10]}; }} QPushButton:pressed {{ background-color: {self.default_colors[9]};}}""")


    def atualizar_interface(self):
        self.plotar_grafico()
        
    def adjust_color(self, base_color, factor):
            """ Adjusts the color by modifying its lightness. """
            r, g, b = base_color
            h, l, s = colorsys.rgb_to_hls(r, g, b)
            l = max(0, min(1, l * factor))
            return colorsys.hls_to_rgb(h, l, s)

    def plotar_grafico(self):
        selected_items = [nome for nome, checkbox in self.checkboxes_arquivos.items() if checkbox.isChecked()]
    
        if not selected_items:
            message_box = QMessageBox()
            message_box.setWindowTitle("Erro")
            message_box.setText("Por favor, selecione pelo menos um nome de arquivo. <i> Quem sabe não muda a pasta?</i>")

            message_box.setIcon(QMessageBox.Warning)
      
            open_button = message_box.addButton("Escolher outra pasta", QMessageBox.ActionRole)
            ok_button = message_box.addButton("Voltar", QMessageBox.AcceptRole)
            message_box.setDefaultButton(ok_button)
          
            message_box.exec()
            if message_box.clickedButton() == open_button:
                self.selecionar_pasta()
            return


        figsize_options = {"Tamanho Único de Coluna (80 mm)": (3.15, 2.36), "Tamanho Duplo de Coluna (170 mm)": (6.69, 5.51),"Tamanho de Página Inteira (210 mm)": (8.27, 5.83),}

# Definindo o tamanho da figura com base na seleção do combobox
        selected_size = self.figsize_combobox.currentText()
        if selected_size.startswith("Customizado"):
            custom_size = self.figsize_options.get("Customizado", (10, 8))
            figsize = (custom_size[0], custom_size[1])
        else:
            figsize = figsize_options.get(selected_size, (10, 8))
            
        dpi_items = {"100": (100), "150": (150), "200": (200), "300": (300),"600": (600)}
        dpi = dpi_items[self.dpi_combobox.currentText()]

        plotar_mesma_figura = self.single_figure_checkbox.isChecked()
        plotar_regressao_linear = self.regression_checkbox.isChecked()
        plotar_bolinhas = self.scatter_checkbox.isChecked()
        plotar_tempo_entre_pressionadas = self.time_between_press_checkbox.isChecked()
        plotar_legendas = self.legend_checkbox.isChecked()
        plotar_press_dur= self.plotar_press_dur.isChecked()
        plotar_media_velocidade = self.mean_velocity_checkbox.isChecked()
        percent_bolinhas = int(self.scatter_percentage_combobox.currentText())
        ligar_bolinhas = self.connect_dots_checkbox.isChecked() 
        fig1, fig2 = None, None  

        if plotar_mesma_figura:
            fig, (ax1, ax4) = plt.subplots(2, 1, figsize=figsize, dpi=dpi)
            ax2 = ax4.twinx()
            ax3 = ax1.twinx()
            fig1, fig2 = fig, fig 
        else:
            fig1, ax1 = plt.subplots(figsize=figsize, dpi=dpi)
            ax3 = ax1.twinx()
            fig2, ax4 = plt.subplots(figsize=figsize, dpi=dpi)
            ax2 = ax4.twinx()
       
        velocity_data = []
        t_data = []
        legend_labels = []
        all_line_styles = [ "-",  (0, (1, 1, 1)), "-.", (0, (1,10, 1)), (0, (3, 1, 1, 1)), (0, (5, 5)), ]
       
        tecla_colors = {
        1: '#1f77b4',  # azul
        2: '#ff7f0e',  # laranja
        3: '#2ca02c',  # verde
        4: '#d62728',  # vermelho
        5: '#9467bd',  # roxo
        6: '#8c564b',  # marrom
        7: '#e377c2',  # rosa
        8: '#7f7f7f',  # cinza
    }
     #   tecla_colors = {}
# Definindo a cor azul para as teclas de 1 a 4
    #    for i in range(1, 5):
     #       tecla_colors[i] = '#1f77b4'  # azul
        # Definindo a cor verde para as teclas de 5 a 8
    #    for i in range(5, 9):
     #       tecla_colors[i] = '#2ca02c'  # verde
     
    

        for idx, nome_inicial_arquivo in enumerate(selected_items):
            base_color = self.cores_selecionadas.get(nome_inicial_arquivo, plt.get_cmap('tab10')(idx % 10)[:3])  # Use the selected color or a default color
            base_color_rgb = tuple(int(base_color.lstrip('#')[i:i+2], 16) / 255.0 for i in (0, 2, 4))  # Convert hex to RGB
            
            diretorio = self.lineedit_dir.text()
            arquivos = os.listdir(diretorio)

            arquivos_takes = [
                int(arquivo.split("_")[-1].split(".")[0]) 
                for arquivo in arquivos 
                if arquivo.startswith(nome_inicial_arquivo + "_take_") 
                and arquivo.endswith(".csv")
                and self.takes_checkboxes[(nome_inicial_arquivo, int(arquivo.split("_")[-1].split(".")[0]))].isChecked()]
            
            for take_idx, num_take in enumerate(arquivos_takes):
                file_path = os.path.join(diretorio, f"{nome_inicial_arquivo}_take_{num_take}.csv")
                if os.path.isfile(file_path):
                    try:
                        tte_dados = pd.read_csv(file_path, sep=" ")
                    except pd.errors.EmptyDataError:
                        QMessageBox.critical(self, "Erro", f"O arquivo {file_path} está vazio.")
                        return
                    if "Tempo" not in tte_dados.columns or "Velocity" not in tte_dados.columns:
                        QMessageBox.critical(self, "Erro", f"O arquivo {file_path} não possui os dados necessários.")
                        return

                    t = tte_dados["Tempo"].values
                    velocity = tte_dados["Velocity"].values
                    velocity_data.append(velocity)
                    tecla = tte_dados["Tecla"].values
                    press_dur = tte_dados["Press_dur"].values       
                    t_data.append(t)
                    t_diff = np.diff(t)
                    
                    
                    
                    
                    # Adiciona uma pequena constante para evitar divisão por zero
                    epsilon = 1e-10
                    t_diff_safe = np.where(t_diff == 0, epsilon, t_diff)
                 
                    press_density = press_dur[1:] / t_diff_safe   #press_density = press_dur[1:] / t_diff
      
                    num_bolinhas = int(len(t) * (percent_bolinhas / 100))
                    random_indices = np.random.choice(len(t), num_bolinhas, replace=False)
                    linestyle = all_line_styles[take_idx % len(all_line_styles)]

                 
                 
                     # Adjust the color slightly for each take
                    color_name = self.adjust_color(base_color_rgb, 1 - 0.1 * take_idx)

                    if plotar_bolinhas and ligar_bolinhas:
                        ax1.scatter(t[random_indices], velocity[random_indices], label=f"{nome_inicial_arquivo} Take {num_take}", linestyle=linestyle, color=color_name, alpha=0.5, edgecolors='black')
                        ax1.plot(t, velocity, linestyle=linestyle, color=color_name, markeredgewidth=7)
                    
                    elif ligar_bolinhas:
                        ax1.plot(t, velocity, label=f"{nome_inicial_arquivo} Take {num_take}", linestyle=linestyle, color=color_name)
                    elif plotar_bolinhas:
                        ax1.scatter(t[random_indices], velocity[random_indices], label=f"{nome_inicial_arquivo} Take {num_take}", linestyle=linestyle, color=color_name, alpha=0.5, edgecolors='black')
                                

                    if plotar_regressao_linear:
                        slope, intercept, _, _, _ = linregress(t, velocity)
                        ax1.plot(t, intercept + slope * t, label=f" R.L {nome_inicial_arquivo} - {num_take}", color=color_name, linestyle=linestyle, alpha=0.5)

                    ax1.set_xlabel("Tempo (ms)")
                    ax1.set_ylabel("Velocity")
                    ax1.set_ylim(0, 127)

                    if plotar_tempo_entre_pressionadas:
                        ax3.plot(t[1:], t_diff, label=f"{nome_inicial_arquivo} Take {num_take}", linestyle=linestyle, color=color_name)
                        ax3.set_ylabel("Tempo entre pressionadas (ms)")
                        ax3.set_xlabel("Tempo (ms)")
                   
                    if plotar_legendas:
                        ax1.legend(loc='best')
                        if not plotar_mesma_figura:
                            fig1.tight_layout() #bbox_to_anchor=(1.05, 1), 

                        if plotar_press_dur:
                            bar_positions = t - (press_dur / 2)
                            bar_widths = press_dur               
                            for position, width, key in zip(bar_positions, bar_widths, tecla):
                                color = tecla_colors.get(key, '#000000') 
                                ax2.hlines(position, width, width,color=color)
                                ax2.bar(position, width, width=width, color=color, edgecolor='black', linestyle= linestyle,alpha=0.8, align='center')
       
                             #   ax2.add_patch(Rectangle((position,width), key, height=1.3))
                                label = f"{nome_inicial_arquivo} Take {num_take}"
                                ax2.text(position, width, label, ha='center', va='bottom', fontsize=8, color='black')

                            ax2.set_xlabel("Tempo (ms)")
                            ax2.set_ylabel("Press_dur (ms)")
                            
                    ax4.plot(t[1:], press_density, label=f"{nome_inicial_arquivo} Take {num_take}", linestyle=linestyle, color=color_name, alpha=0.8)
                    ax4.set_ylabel("Densidade temporal das pressionadas")
                    ax4.set_title("Press Density")
                    
                    if plotar_legendas:
                        ax4.legend(loc='best')
                else:
                    QMessageBox.critical(self, "Erro", f"O arquivo {file_path} não foi encontrado.")
                    
        if plotar_legendas:
            handles, labels = ax4.get_legend_handles_labels()
            filtered_handles = [handle for handle, label in zip(handles, labels) if not label.startswith('_')]
            ax4.legend(loc='best', handles=filtered_handles)
        
        if velocity_data:
            min_len = min(len(v) for v in velocity_data)
            t_common = np.linspace(min(t_data[0]), max(t_data[0]), min_len)
            extra_space = 500  
            max_time =  max(t_common)
            velocity_data_interpolated = [np.interp(t_common, t, v) for t, v in zip(t_data, velocity_data)]
            mean_velocity = np.mean(velocity_data_interpolated, axis=0)
        
            if plotar_media_velocidade:
                ax1.plot(t_common, mean_velocity, label='Mean Velocity', color='gray', alpha=0.8, linestyle='-')
                if plotar_legendas:
                    ax1.legend(loc='best')

            if plotar_mesma_figura:
                plt.tight_layout()  
                plt.subplots_adjust(hspace=0.45, top=0.95, bottom=0.1)  # Ajusta os espaços entre os subplots e margens
            else:
                fig1.tight_layout()
                fig1.subplots_adjust(top=0.95, bottom=0.1)

            xticks = np.arange(0, max_time + extra_space, 1000)     # Definindo os valores nos eixos x sempre de 1000 em 1000
            ax1.set_xticks(xticks)
            ax1.set_xticklabels([f"{int(x)}" for x in xticks])

            ax1.xaxis.set_minor_locator(plt.MultipleLocator(1000))
            ax1.grid(which='both', linestyle='-', linewidth=0.5, alpha=0.5)
            ax4.xaxis.set_minor_locator(plt.MultipleLocator(1000))
            ax4.grid(which='both', linestyle='-', linewidth=0.5, alpha=0.5)

            for ax in [ax1, ax2, ax3, ax4]:
                ax.set_xticks(ax4.get_xticks())
                ax.set_xticklabels(ax4.get_xticklabels()) 
            ax1.tick_params(axis='both', which='major', labelsize=10)
            ax.set_xlim(0, max_time + extra_space)  # Definindo o limite inferior do eixo x para 0
            ax4.set_xlim(0, max_time + extra_space)  # Definindo o limite inferior do eixo x para 0
            
        # Salvamento direto das figuras
        save_dir = "imagens_salvas"
        os.makedirs(save_dir, exist_ok=True)
        
        save_name = self.save_name_input.text().strip() or "figura"
        if plotar_mesma_figura:
            fig1.savefig(f"{save_name}.png")
        else:
            fig1.savefig(f"{save_name}_velocity_time.png")
            fig2.savefig(f"{save_name}_press_density.png")
            
        fig1.show()
        if fig2:
            fig2.show()
        
if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = PlotarGrafico()
    window.show()
    sys.exit(app.exec_())
