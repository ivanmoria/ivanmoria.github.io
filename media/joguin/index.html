<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Pega-pega harmônico</title>
<style>
     body, button, div {
    touch-action: manipulation;
  }
  body {
    background-color: black;
    color: white;
    font-family: Arial, sans-serif;
    user-select: none;
    margin: 0;
    padding: 0;
    text-align: center;
  }
  /* Canvas responsivo: largura máxima 100%, altura automática */
  canvas {
    background-color: black;
    display: block;
    margin: 20px auto;
    width: 90vw;
    max-width: 640px;
    height: auto;
    aspect-ratio: 1 / 1;
  }
  #score {
    font-size: 5vw;
    margin: 10px;
  }
  #gameOverOverlay {
    position: fixed;
    top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.7);
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    color: yellow; font-size: 10vw;
    font-weight: bold;
    visibility: hidden;
    z-index: 10;
  }
  #restartBtn {
    margin-top: 20px;
    padding: 10px 30px;
    font-size: 6vw;
    background-color: gray;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    touch-action: manipulation;
  }
  #restartBtn:hover {
    background-color: darkgray;
  }
  #startOverlay {
    position: fixed; top:0; left:0; width:100vw; height:100vh;
    background: rgba(0,0,0,0.85);
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 8vw;
    cursor: pointer;
    user-select: none;
    z-index: 20;
  }
#touchControls {
  position: fixed;
  top: 70%;
  right: 5%;
  transform: translateY(-50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0px;
  z-index: 30;
  user-select: none;
}

/* Botão "para cima" */
#touchControls > button.up {
  width: 80px;
  height: 80px;
  font-size: 40px;
  background-color: gray;
  border-radius: 50%;
  color: white;
  border: none;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
}

/* Container do meio com esquerda e direita */
#touchControls > div.middle-row {
  display: flex;
  justify-content: space-between;
  width: 180px; /* espaço para os dois botões lado a lado */
}

#touchControls button.left,
#touchControls button.right,
#touchControls button.down {
  width: 80px;
  height: 80px;
  font-size: 40px;
  background-color: gray;
  border-radius: 50%;
  color: white;
  border: none;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
}

/* Botão para baixo fica abaixo */
#touchControls > button.down {
  margin-top: 10px;
}

/* Hover e foco */
#touchControls button:hover,
#touchControls button:focus {
  background-color: darkgray;
  outline: none;
}

/* Responsivo */
@media (max-width: 400px) {
  #touchControls button {
    width: 20vw;
    height: 20vw;
    font-size: 10vw;
    max-width: none;
    max-height: none;
  }
}

  
  
</style>

<script>
// Bloqueia double tap zoom
let lastTouchEnd = 0;
document.addEventListener('touchend', function(event) {
  const now = new Date().getTime();
  if (now - lastTouchEnd <= 300) {
    event.preventDefault();
  }
  lastTouchEnd = now;
}, false);
</script>
</head>
<body>

<div id="touchControls" role="group" aria-label="Controles do jogo para toque">
  <button type="button" aria-label="Mover para cima" class="up" onclick="movePlayer('up')">W</button>
  <div class="middle-row">
    <button type="button" aria-label="Mover para esquerda" class="left" onclick="movePlayer('left')">A</button>
    <button type="button" aria-label="Mover para direita" class="right" onclick="movePlayer('right')">D</button>
  </div>
  <button type="button" aria-label="Mover para baixo" class="down" onclick="movePlayer('down')">S</button>
</div>


<div id="score">Score: 0</div>
<canvas id="gameCanvas" width="640" height="640"></canvas>

<div id="gameOverOverlay" role="alert" aria-live="assertive">
  oooops!
  <button id="restartBtn">Reiniciar</button>
</div>

<audio id="audioFundo" src="/media/joguin/musica_fundo.mp3" preload="auto"></audio>

<div id="startOverlay">Clique para iniciar o jogo</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
  }
  window.addEventListener('resize', () => {
    resizeCanvas();
    draw();
  });
  resizeCanvas();

  const ROWS = 8;
  const COLS = 8;
  let WIDTH = canvas.width;
  let HEIGHT = canvas.height;
  let SQUARE_SIZE = WIDTH / COLS;

  const COLORS = {
    YELLOW: '#FFFF00',
    RED: '#FF0000',
    BLUE: '#0000FF',
    LIGHT_BROWN: '#DEB887',
    BROWN: '#8B4513',
    BLACK: '#000000',
    WHITE: '#FFFFFF',
    GRAY: '#C8C8C8',
    DARK_GRAY: '#646464',
  };

  let dangerPositions = [];
  let playerPos = { row: 7, col: 0 };
  let targetPos = null;
  let score = 0;
  let gameOver = false;
  let laserIndex = 0;
  let laserTimes = [];
  let startTime = null;

  const scoreDiv = document.getElementById('score');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const restartBtn = document.getElementById('restartBtn');
  const audioFundo = document.getElementById('audioFundo');
  const startOverlay = document.getElementById('startOverlay');

  async function loadCSV() {
    try {
      const response = await fetch('layers.csv');
      if (!response.ok) throw new Error('Não foi possível carregar layers.csv');
      const text = await response.text();
      const lines = text.trim().split('\n');
      laserTimes = lines.slice(1).map(line => {
        const cols = line.split(',');
        return parseFloat(cols[0]);
      }).filter(t => !isNaN(t));
      console.log('Tempos carregados do CSV:', laserTimes);
    } catch (error) {
      console.error('Erro ao carregar CSV:', error);
      laserTimes = [2,5,8,12,15];
    }
  }

  function drawBoard() {
    WIDTH = canvas.width;
    HEIGHT = canvas.height;
    SQUARE_SIZE = WIDTH / COLS;
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        const isLight = (r + c) % 2 === 0;
        ctx.fillStyle = isLight ? COLORS.LIGHT_BROWN : COLORS.BROWN;
        ctx.fillRect(c * SQUARE_SIZE, r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
      }
    }
  }

  function drawLasers() {
    const radius = SQUARE_SIZE / 3;
    dangerPositions.forEach(pos => {
      const centerX = pos.col * SQUARE_SIZE + SQUARE_SIZE / 2;
      const centerY = pos.row * SQUARE_SIZE + SQUARE_SIZE / 2;
      ctx.fillStyle = COLORS.YELLOW;
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  function drawPlayer() {
    const radius = SQUARE_SIZE / 3;
    const centerX = playerPos.col * SQUARE_SIZE + SQUARE_SIZE / 2;
    const centerY = playerPos.row * SQUARE_SIZE + SQUARE_SIZE / 2;
    ctx.fillStyle = COLORS.RED;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawTarget() {
    if (!targetPos) return;
    const radius = SQUARE_SIZE / 3;
    const centerX = targetPos.col * SQUARE_SIZE + SQUARE_SIZE / 2;
    const centerY = targetPos.row * SQUARE_SIZE + SQUARE_SIZE / 2;
    ctx.fillStyle = COLORS.BLUE;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.fill();
  }

  function spawnDangerPositions() {

    const possiblePositions = [];
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
        const isPlayer = (r === playerPos.row && c === playerPos.col);
        const isTarget = targetPos && (r === targetPos.row && c === targetPos.col);
        if (!isPlayer && !isTarget) {
            possiblePositions.push({ row: r, col: c });
        }
        }
    }
    const shuffled = possiblePositions.sort(() => 0.5 - Math.random());
    return shuffled.slice(0, 10);
    }


  function spawnTarget() {
    const possiblePositions = [];
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        if (!(r === playerPos.row && c === playerPos.col) &&
            !dangerPositions.some(p => p.row === r && p.col === c)) {
          possiblePositions.push({row: r, col: c});
        }
      }
    }
    if (possiblePositions.length === 0) return null;
    return possiblePositions[Math.floor(Math.random() * possiblePositions.length)];
  }

  // Função movePlayer global para os botões funcionarem
  window.movePlayer = function(direction) {
    if (gameOver) return;
    let { row, col } = playerPos;
    if (direction === 'up' && row > 0) row--;
    else if (direction === 'down' && row < ROWS - 1) row++;
    else if (direction === 'left' && col > 0) col--;
    else if (direction === 'right' && col < COLS - 1) col++;
    playerPos = { row, col };
    update();
    draw();
  };

  function update() {
    if (!startTime) startTime = performance.now();
    const elapsedSeconds = (performance.now() - startTime) / 1000;

    if (!gameOver) {
      if (laserIndex < laserTimes.length && elapsedSeconds >= laserTimes[laserIndex]) {
        dangerPositions = spawnDangerPositions();
        laserIndex++;
      }

      if (targetPos && playerPos.row === targetPos.row && playerPos.col === targetPos.col) {
        score++;
        targetPos = null;
        updateScore();
      }

      if (!targetPos) {
        targetPos = spawnTarget();
      }

      if (dangerPositions.some(p => p.row === playerPos.row && p.col === playerPos.col)) {
        gameOver = true;
        audioFundo.pause();
        showGameOver();
      }
    }
  }

  function updateScore() {
    scoreDiv.textContent = `Score: ${score}`;
  }

  function draw() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawBoard();
    drawLasers();
    drawPlayer();
    drawTarget();
  }

  function gameLoop() {
    update();
    draw();
    if (!gameOver) {
      requestAnimationFrame(gameLoop);
    }
  }

  function showGameOver() {
    gameOverOverlay.style.visibility = 'visible';
  }

  function hideGameOver() {
    gameOverOverlay.style.visibility = 'hidden';
  }

  function resetGame() {
    playerPos = {row: 7, col: 0};
    score = 0;
    updateScore();
    dangerPositions = [];
    laserIndex = 0;
    targetPos = null;
    startTime = null;
    gameOver = false;
    hideGameOver();
    audioFundo.currentTime = 0;
    audioFundo.play().catch(err => {
      console.log('Erro ao tocar áudio:', err);
    });
    gameLoop();
  }

  window.addEventListener('keydown', e => {
    if (gameOver) return;
    switch(e.key.toLowerCase()) {
      case 'w': movePlayer('up'); break;
      case 'a': movePlayer('left'); break;
      case 's': movePlayer('down'); break;
      case 'd': movePlayer('right'); break;
    }
  });

  restartBtn.addEventListener('click', () => {
    resetGame();
  });
    audioFundo.addEventListener('ended', () => {
    if (!gameOver) {
        gameOver = true;
        showGameOver();
    }
    });

    function showGameOver() {
    gameOverOverlay.innerHTML = `Fim do Jogo!<br>Score: ${score}`;
    const restartButton = document.createElement('button');
    restartButton.id = 'restartBtn';
    restartButton.textContent = 'Reiniciar';
    restartButton.style.marginTop = '20px';
    restartButton.style.padding = '10px 30px';
    restartButton.style.fontSize = '6vw';
    restartButton.style.backgroundColor = 'gray';
    restartButton.style.border = 'none';
    restartButton.style.borderRadius = '6px';
    restartButton.style.cursor = 'pointer';
    restartButton.addEventListener('click', () => {
        resetGame();
    });
    gameOverOverlay.appendChild(restartButton);
    gameOverOverlay.style.visibility = 'visible';
    }

  startOverlay.addEventListener('click', () => {
    loadCSV().then(() => {
      startOverlay.style.display = 'none';
      audioFundo.currentTime = 0;
      audioFundo.play().catch(err => {
        console.log('Erro ao tocar o áudio:', err);
      });
      resetGame();
    });
  });

  draw();

})();
</script>

</body>
</html>
