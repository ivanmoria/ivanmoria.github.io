<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jogo com CSV e Áudio</title>
<style>
  body { background-color: black; color: white; font-family: Arial, sans-serif; user-select: none; margin: 0; padding: 0; text-align: center;}
  canvas { background-color: black; display: block; margin: 20px auto;}
  #score { font-size: 24px; margin: 10px;}
  #gameOverOverlay {
    position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.7);
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    color: yellow; font-size: 48px; font-weight: bold; visibility: hidden;
    z-index: 10;
  }
  #restartBtn {
    margin-top: 20px; padding: 10px 30px; font-size: 24px;
    background-color: gray; border: none; border-radius: 6px; cursor: pointer;
  }
  #restartBtn:hover { background-color: darkgray;}
  #startOverlay {
    position: fixed; top:0; left:0; width:100vw; height:100vh;
    background: rgba(0,0,0,0.85);
    color: white; display: flex;
    justify-content: center; align-items: center;
    font-size: 32px; cursor: pointer; user-select: none;
    z-index: 20;
  }
</style>
</head>
<div id="touchControls">
  <button onclick="movePlayer('up')">▲</button>
  <div>
    <button onclick="movePlayer('left')">◀</button>
    <button onclick="movePlayer('right')">▶</button>
  </div>
  <button onclick="movePlayer('down')">▼</button>
</div>

<style>
  #touchControls {
  position: fixed;
  bottom: 20px;
  left: 20px;
  text-align: center;
  z-index: 30;
  user-select: none;
  font-size: 0; /* Remove espaço inline entre botões */

  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
}

#touchControls > div {
  display: flex;
  justify-content: center;
  gap: 40px; /* Espaço entre esquerda e direita */
}

#touchControls button {
  background-color: gray;
  border: none;
  border-radius: 8px;
  padding: 20px 25px;
  font-size: 28px;
  color: white;
  cursor: pointer;
  touch-action: manipulation;
  user-select: none;
  width: 60px;
  height: 60px;
  line-height: 1;
}

#touchControls button:hover {
  background-color: darkgray;
}

</style>






<body>

<div id="score">Score: 0</div>
<canvas id="gameCanvas" width="640" height="640"></canvas>

<div id="gameOverOverlay">
  GAME OVER!
  <button id="restartBtn">Reiniciar</button>
</div>

<audio id="audioFundo" src="/media/joguin/musica_fundo.mp3" preload="auto"></audio>

<div id="startOverlay">Clique para iniciar o jogo</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const ROWS = 8;
  const COLS = 8;
  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;
  const SQUARE_SIZE = WIDTH / COLS;

  const COLORS = {
    YELLOW: '#FFFF00',
    RED: '#FF0000',
    BLUE: '#0000FF',
    LIGHT_BROWN: '#DEB887',
    BROWN: '#8B4513',
    BLACK: '#000000',
    WHITE: '#FFFFFF',
    GRAY: '#C8C8C8',
    DARK_GRAY: '#646464',
  };

  let dangerPositions = [];
  let playerPos = { row: 7, col: 0 };
  let targetPos = null;
  let score = 0;
  let gameOver = false;
  let laserIndex = 0;
  let laserTimes = [];  // será carregado do CSV
  let startTime = null;

  const scoreDiv = document.getElementById('score');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const restartBtn = document.getElementById('restartBtn');
  const audioFundo = document.getElementById('audioFundo');
  const startOverlay = document.getElementById('startOverlay');

  // Função para carregar CSV layers.csv e extrair tempos (em segundos)
  async function loadCSV() {
    try {
      const response = await fetch('layers.csv');
      if (!response.ok) throw new Error('Não foi possível carregar layers.csv');
      const text = await response.text();
      const lines = text.trim().split('\n');

      // Supondo que a primeira linha é header e que o CSV tem uma coluna com os tempos (ex: tempo_s)
      laserTimes = lines.slice(1).map(line => {
        const cols = line.split(',');
        return parseFloat(cols[0]);
      }).filter(t => !isNaN(t));

      console.log('Tempos carregados do CSV:', laserTimes);
    } catch (error) {
      console.error('Erro ao carregar CSV:', error);
      // Fallback: tempos fixos para teste
      laserTimes = [2,5,8,12,15];
    }
  }

  function drawBoard() {
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        const isLight = (r + c) % 2 === 0;
        ctx.fillStyle = isLight ? COLORS.LIGHT_BROWN : COLORS.BROWN;
        ctx.fillRect(c * SQUARE_SIZE, r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
      }
    }
  }

  function drawLasers() {
    const radius = SQUARE_SIZE / 3;
    dangerPositions.forEach(pos => {
      const centerX = pos.col * SQUARE_SIZE + SQUARE_SIZE / 2;
      const centerY = pos.row * SQUARE_SIZE + SQUARE_SIZE / 2;
      ctx.fillStyle = COLORS.YELLOW;
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  function drawPlayer() {
    const radius = SQUARE_SIZE / 3;
    const centerX = playerPos.col * SQUARE_SIZE + SQUARE_SIZE / 2;
    const centerY = playerPos.row * SQUARE_SIZE + SQUARE_SIZE / 2;
    ctx.fillStyle = COLORS.RED;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawTarget() {
    if (!targetPos) return;
    const radius = SQUARE_SIZE / 3;
    const centerX = targetPos.col * SQUARE_SIZE + SQUARE_SIZE / 2;
    const centerY = targetPos.row * SQUARE_SIZE + SQUARE_SIZE / 2;
    ctx.fillStyle = COLORS.BLUE;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.fill();
  }

  function spawnDangerPositions() {
    const possiblePositions = [];
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
        // Só adiciona posições que NÃO sejam onde o jogador está
        if (!(r === playerPos.row && c === playerPos.col)) {
            possiblePositions.push({ row: r, col: c });
        }
        }
    }
    const shuffled = possiblePositions.sort(() => 0.5 - Math.random());
    return shuffled.slice(0, 10);  // pega até 5 posições
    }

  function spawnTarget() {
    const possiblePositions = [];
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        if (!(r === playerPos.row && c === playerPos.col) &&
            !dangerPositions.some(p => p.row === r && p.col === c)) {
          possiblePositions.push({row: r, col: c});
        }
      }
    }
    if (possiblePositions.length === 0) return null;
    return possiblePositions[Math.floor(Math.random() * possiblePositions.length)];
  }

  function movePlayer(direction) {
    if (gameOver) return;
    let { row, col } = playerPos;
    if (direction === 'up' && row > 0) row--;
    else if (direction === 'down' && row < ROWS - 1) row++;
    else if (direction === 'left' && col > 0) col--;
    else if (direction === 'right' && col < COLS - 1) col++;

    playerPos = { row, col };

    // ✅ Atualiza o jogo logo depois de mover (quando for via touch/mouse)
    update();
    draw();
    }

  function update() {
  if (!startTime) startTime = performance.now();
  const elapsedSeconds = (performance.now() - startTime) / 1000;

  if (!gameOver) {
    if (laserIndex < laserTimes.length && elapsedSeconds >= laserTimes[laserIndex]) {
      dangerPositions = spawnDangerPositions();
      laserIndex++;
    }

    if (targetPos && playerPos.row === targetPos.row && playerPos.col === targetPos.col) {
      score++;
      targetPos = null;
      updateScore();
    }

    if (!targetPos) {
      targetPos = spawnTarget();
    }

    if (dangerPositions.some(p => p.row === playerPos.row && p.col === playerPos.col)) {
      gameOver = true;
      audioFundo.pause();
      showGameOver();
    }
  }
}

  function updateScore() {
    scoreDiv.textContent = `Score: ${score}`;
  }

  function draw() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawBoard();
    drawLasers();
    drawPlayer();
    drawTarget();
  }

  function gameLoop() {
    update();
    draw();
    if (!gameOver) {
      requestAnimationFrame(gameLoop);
    }
  }

  function showGameOver() {
    gameOverOverlay.style.visibility = 'visible';
  }

  function hideGameOver() {
    gameOverOverlay.style.visibility = 'hidden';
  }

  function resetGame() {
    playerPos = {row: 7, col: 0};
    score = 0;
    updateScore();
    dangerPositions = [];
    laserIndex = 0;
    targetPos = null;
    startTime = null;
    gameOver = false;
    hideGameOver();
    audioFundo.currentTime = 0;
    audioFundo.play().catch(err => {
      console.log('Erro ao tocar áudio:', err);
    });
    gameLoop();
  }

  window.addEventListener('keydown', e => {
    if (gameOver) return;
    switch(e.key.toLowerCase()) {
      case 'w': movePlayer('up'); break;
      case 'a': movePlayer('left'); break;
      case 's': movePlayer('down'); break;
      case 'd': movePlayer('right'); break;
    }
  });

  restartBtn.addEventListener('click', () => {
    resetGame();
  });

  // Ao clicar no overlay inicial, inicia o jogo
startOverlay.addEventListener('click', () => {
  loadCSV().then(() => {
    startOverlay.style.display = 'none';
    audioFundo.currentTime = 0;
    audioFundo.play().catch(err => {
      console.log('Erro ao tocar o áudio:', err);
    });
    resetGame();
  });
});


})();
</script>

</body>
</html>
