<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Pega-pega harmônico</title>
<style>
  body, button, div {
    touch-action: manipulation;
  }
  body {
    background-color: black;
    color: white;
    font-family: Arial, sans-serif;
    user-select: none;
    margin: 0;
    padding: 0;
    text-align: center;
  }
  canvas {
    background-color: black;
    display: block;
    margin: 20px auto;
    width: 90vw;
    max-width: 640px;
    height: auto;
    aspect-ratio: 1 / 1;
  }
  #score {
    font-size: 5vw;
    margin: 10px;
  }
  #gameOverOverlay {
    position: fixed;
    top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.7);
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    color: yellow; font-size: 10vw;
    font-weight: bold;
    visibility: hidden;
    z-index: 10;
  }
  #restartBtn {
    margin-top: 20px;
    padding: 10px 30px;
    font-size: 6vw;
    background-color: gray;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    touch-action: manipulation;
  }
  #restartBtn:hover {
    background-color: darkgray;
  }
  #startOverlay {
    position: fixed;
    top:0;
    left:0;
    width:100vw;
    height:100vh;
    background: rgba(0,0,0,0.85);
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-size: 6vw;
    user-select: none;
    z-index: 20;
  }
  #startOverlay button {
    margin: 10px;
    padding: 15px 40px;
    font-size: 6vw;
    background-color: gray;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    color: white;
  }
  #startOverlay button:hover {
    background-color: darkgray;
  }
  #touchControls {
    position: fixed;
    top: 80%;
    right: 15%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0px;
    z-index: 30;
    user-select: none;
  }
  #touchControls > button,
  #touchControls button.left,
  #touchControls button.right,
  #touchControls button.down {
    width: 50px;
    height: 50px;
    font-size: 40px;
    background-color: gray;
    border-radius: 50%;
    color: white;
    border: none;
    cursor: pointer;
  }
  @media (max-width: 400px) {
    #touchControls button {
      width: 20vw;
      height: 20vw;
      font-size: 10vw;
      max-width: none;
      max-height: none;
    }
  }
</style>

<script>
document.addEventListener('touchend', function(event) {
  const now = new Date().getTime();
  if (now - (window.lastTouchEnd || 0) <= 300) event.preventDefault();
  window.lastTouchEnd = now;
}, false);
</script>
</head>
<body>

<div id="touchControls" role="group" aria-label="Controles do jogo para toque">
  <button type="button" class="up" onclick="movePlayer('up')">W</button>
  <div class="middle-row">
    <button type="button" class="left" onclick="movePlayer('left')">A</button>
    <button type="button" class="right" onclick="movePlayer('right')">D</button>
  </div>
  <button type="button" class="down" onclick="movePlayer('down')">S</button>
</div>

<div id="score">Score: 0 | Vidas: 0</div>
<canvas id="gameCanvas" width="640" height="640"></canvas>

<div id="gameOverOverlay" role="alert" aria-live="assertive"></div>

<audio id="audioFundo" src="/media/joguin/musica_fundo.mp3" preload="auto"></audio>

<div id="startOverlay">
  <div>Escolha o modo:</div>
  <button onclick="startGame('normal')">Modo Normal</button>
  <button onclick="startGame('hardcore')">Modo Hardcore</button>
</div>





<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  let gameMode = 'normal';
  const ROWS = 8;
  const COLS = 8;
  let WIDTH = canvas.width;
  let HEIGHT = canvas.height;
  let SQUARE_SIZE = WIDTH / COLS;
  const COLORS = { YELLOW: '#FFFF00', RED: '#FF0000', BLUE: '#0000FF', GREEN: '#00FF00', LIGHT_BROWN: '#DEB887', BROWN: '#8B4513' };

  let dangerPositions = [];
  let playerPos = { row: 7, col: 0 };
  let targetPos = null;
  let greenPos = null;
  let score = 0;
  let lives = 0;
  let gameOver = false;
  let laserIndex = 0;
  let laserTimes = [];
  let startTime = null;

  const scoreDiv = document.getElementById('score');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const audioFundo = document.getElementById('audioFundo');
  const startOverlay = document.getElementById('startOverlay');

  async function loadCSV() {
    try {
      const response = await fetch('layers.csv');
      if (!response.ok) throw new Error('Erro ao carregar layers.csv');
      const text = await response.text();
      const lines = text.trim().split('\n');
      laserTimes = lines.slice(1).map(line => parseFloat(line.split(',')[0])).filter(t => !isNaN(t));
    } catch {
      laserTimes = [2, 5, 8, 12, 15];
    }
  }

  function drawBoard() {
    WIDTH = canvas.width;
    HEIGHT = canvas.height;
    SQUARE_SIZE = WIDTH / COLS;
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        ctx.fillStyle = (r+c)%2===0 ? COLORS.LIGHT_BROWN : COLORS.BROWN;
        ctx.fillRect(c*SQUARE_SIZE, r*SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
      }
    }
  }

  function drawElements() {
    const radius = SQUARE_SIZE / 3;

    dangerPositions.forEach(pos => {
      ctx.fillStyle = COLORS.YELLOW;
      ctx.beginPath();
      ctx.arc(pos.col*SQUARE_SIZE+SQUARE_SIZE/2, pos.row*SQUARE_SIZE+SQUARE_SIZE/2, radius, 0, Math.PI*2);
      ctx.fill();
    });

    if (targetPos) {
      ctx.fillStyle = COLORS.BLUE;
      ctx.beginPath();
      ctx.arc(targetPos.col*SQUARE_SIZE+SQUARE_SIZE/2, targetPos.row*SQUARE_SIZE+SQUARE_SIZE/2, radius, 0, Math.PI*2);
      ctx.fill();
    }

    if (greenPos) {
      ctx.fillStyle = COLORS.GREEN;
      ctx.beginPath();
      ctx.arc(greenPos.col*SQUARE_SIZE+SQUARE_SIZE/2, greenPos.row*SQUARE_SIZE+SQUARE_SIZE/2, radius, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.fillStyle = COLORS.RED;
    ctx.beginPath();
    ctx.arc(playerPos.col*SQUARE_SIZE+SQUARE_SIZE/2, playerPos.row*SQUARE_SIZE+SQUARE_SIZE/2, radius, 0, Math.PI*2);
    ctx.fill();
  }

  window.movePlayer = function(direction) {
    if (gameOver) return;
    let { row, col } = playerPos;
    if (direction==='up' && row>0) row--;
    else if (direction==='down' && row<ROWS-1) row++;
    else if (direction==='left' && col>0) col--;
    else if (direction==='right' && col<COLS-1) col++;
    playerPos = { row, col };
    update();
    draw();
  };

  function spawnDangerPositions() {
    const positions = [];
    for (let r=0; r<ROWS; r++) {
      for (let c=0; c<COLS; c++) {
        if ((r!==playerPos.row || c!==playerPos.col) &&
            (!targetPos || r!==targetPos.row || c!==targetPos.col) &&
            (!greenPos || r!==greenPos.row || c!==greenPos.col)) {
          positions.push({row:r, col:c});
        }
      }
    }
    return positions.sort(()=>0.5-Math.random()).slice(0,10);
  }

  function spawnTarget() {
    const positions = [];
    for (let r=0; r<ROWS; r++) {
      for (let c=0; c<COLS; c++) {
        const occupied = (r===playerPos.row && c===playerPos.col) ||
                         dangerPositions.some(p=>p.row===r && p.col===c) ||
                         (greenPos && r===greenPos.row && c===greenPos.col);
        if (!occupied) positions.push({row:r, col:c});
      }
    }
    return positions.length ? positions[Math.floor(Math.random()*positions.length)] : null;
  }

  function spawnGreen() {
    const positions = [];
    for (let r=0; r<ROWS; r++) {
      for (let c=0; c<COLS; c++) {
        const occupied = (r === playerPos.row && c === playerPos.col) ||
                         (targetPos && r === targetPos.row && c === targetPos.col) ||
                         dangerPositions.some(p => p.row === r && p.col === c);
        if (!occupied) positions.push({ row: r, col: c });
      }
    }
    greenPos = positions.length ? positions[Math.floor(Math.random() * positions.length)] : null;
  }

  function updateScore() {
    scoreDiv.textContent = `Score: ${score} | Vidas: ${lives}`;
  }

  function update() {
    if (!startTime) startTime = performance.now();
    const elapsed = (performance.now() - startTime) / 1000;

    if (!gameOver) {
      if (laserIndex < laserTimes.length && elapsed >= laserTimes[laserIndex]) {
        dangerPositions = spawnDangerPositions();
        laserIndex++;
      }

      // Captura da azul
      if (targetPos && playerPos.row === targetPos.row && playerPos.col === targetPos.col) {
        score++;
        targetPos = null;
        updateScore();

        if (score % 10 === 0 && !greenPos) {
          spawnGreen();
        }
      }

      // Captura da verde
      if (greenPos && playerPos.row === greenPos.row && playerPos.col === greenPos.col) {
        score += 3;
        lives += 1;
        greenPos = null;
        updateScore();
      }

      // Colisão com amarelas
      if (dangerPositions.some(p => p.row === playerPos.row && p.col === playerPos.col)) {
        if (!damageCooldown) {  // só aplica dano se não estiver em cooldown
            if (lives > 0) {
            lives -= 1;
            updateScore();
            } else {
            if (gameMode === 'normal') {
                score = 0;
                updateScore();
            } else if (gameMode === 'hardcore') {
                gameOver = true;
                audioFundo.pause();
                showGameOver();
            }
            }
            damageCooldown = true;  // bloqueia dano imediato
            // Libera dano após 1 segundo (1000 ms)
            setTimeout(() => {
            damageCooldown = false;
            }, 1000);
        }
        } else {
        // Se o jogador não está mais em cima da bolinha amarela, libera para próximo dano
        damageCooldown = false;
        }
      if (!targetPos) targetPos = spawnTarget();
    }
  }

  function draw() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawBoard();
    drawElements();
  }

  function gameLoop() {
    update();
    draw();
    if (!gameOver) requestAnimationFrame(gameLoop);
  }

  function showGameOver() {
    gameOverOverlay.innerHTML = `Fim do Jogo!<br>Score: ${score}<br>Vidas: ${lives}<br><button id="restartBtn">Reiniciar</button>`;
    gameOverOverlay.style.visibility = 'visible';
    document.getElementById('restartBtn').onclick = resetGame;
  }

  function hideGameOver() {
    gameOverOverlay.style.visibility = 'hidden';
  }

  function resetGame() {
    playerPos = { row: 7, col: 0 };
    score = 0;
    lives = 0;
    updateScore();
    dangerPositions = [];
    laserIndex = 0;
    targetPos = null;
    greenPos = null;
    startTime = null;
    gameOver = false;
    hideGameOver();
    audioFundo.currentTime = 0;
    audioFundo.play().catch(err => console.log('Erro ao tocar áudio:', err));
    gameLoop();
  }

  function startGame(mode) {
    gameMode = mode;
    loadCSV().then(() => {
      startOverlay.style.display = 'none';
      audioFundo.currentTime = 0;
      audioFundo.play().catch(err => console.log('Erro ao tocar o áudio:', err));
      resetGame();
    });
  }

  // Tornar startGame visível globalmente:
  window.startGame = startGame;

  window.addEventListener('keydown', e => {
    if (gameOver) return;
    switch (e.key.toLowerCase()) {
      case 'w': movePlayer('up'); break;
      case 'a': movePlayer('left'); break;
      case 's': movePlayer('down'); break;
      case 'd': movePlayer('right'); break;
    }
  });

  audioFundo.addEventListener('ended', () => {
    if (!gameOver) {
      gameOver = true;
      showGameOver();
    }
  });

  draw();
})();
</script>













</body>
</html>
